прога 5 лаба теория

1. comparable/comparator
	сomparable:
		compareTo() сравнивает себя с другим объектом того же типа, возвращает отрицательное число, если вызывающий объект меньше того, с которым сравнивается; положительное, если больше и ноль, если равны
		классы, реализующие интерфейс могут использоваться для сортировки встроенными методами как collection.sort() 
		внутреннее сравнение 
	сomparator
		compare() переопределяется внутри метода, в котором используется, позволяет сравнивать объекты разных классов и по разным критериям
		внешнее сравнение

2. Коллекции в java
	* ArrayList - массив, быстрый доступ по индексу, но медленные вставки и удаления в середине списка
	* LinkedList - быстрые вставки и удаление в середине списка, но медленный доступ по индексу
	* HashSet - реализация на основе хэш-таблицы, быстрое добавление, удаление и проверка наличия элементов, но не гарантирует порядка
	* TreeSet - множество на основе дерева, отсортированный порядок, быстрое добавление, удаление и поиск
	* HashMap - словарь на основе хэш-таблицы, хранит пары ключ-значение, обеспечивает быстрый доступ к значению по ключу
	* TreeMap - словарь на основе дерева, обеспечивает элементы в отсортированном порядке
	* ArrayDeque - двусторонняя очередь на основе массива. эффективно добавляет и удаляет элементы как в начале, так и в конце очереди

	устройство hashmap:
		* использует массив для хранения
		* сначала вычисляется хэш-код ключа, затем определяется индекс для хранения, для определения ячейки используется хэш-функция
		* если происходит коллизия, то хранится в одном месте в виде связанного списка, используетя метод цепочек или метод открытой адресации
		* если будет попытка добавить элемент с ключом, который уже присутствует, то его значение будет перезаписано 
		* может содержать один нулл ключи и множество нулл значений
		* не является синхронизированным 
		*Когда мы передаем пару "ключ-значение" в HashMap, она использует ключ, чтобы вычислить хэш, который затем используется для определения индекса в массиве, где хранится значение.
	устройство hashset: 
		* внутри образуется экземпляр hashmap, в котором значения это нулл, а ключи это добавленные элементы
		* когда элемент добавляется, он добавляется как ключ внутри hashmap, дубликаты игнорируются
		* если происходит коллизия, то хранится в одном месте в виде связанного списка, используетя метод цепочек или метод открытой адресации
		* Если попытаться добавить элемент, который уже присутствует в HashSet, операция добавления не приведет к изменению состояния коллекции.
		* элементы не упорядочены, порядок зависит от результатов хэширование
		
	3. stream - последовательность элементов, которую можно обрабатывать последовательно или параллельно
		* отвечает за фильтрацию, отображение, сортировку коллекций
		* способы создания: пустой, из лист, мап, эррей, указанных элементов
		* стрим нельзя использовать повторно
		* терминальные(фор ич, каунт)/промежуточные(мап, фильтр)
		* промежуточные операции не выполняются без терминальных, их запускает терминальная
		* последовательная обработка выполняется по умолчанию, подходит для небольших коллекций, операции выполняются на одном объекте поочередно
		* параллельная обработка может обрабатывать несколько потоков одновременно. эффективна для больших коллекций.
		* параллельная обработка не всегда приводит к повышению производительности.

	4. io/nio
		* input/output - эффективен для небольших потоках данных и символьных потоках, Чтение и запись выполняются синхронно, что означает, что поток ожидает, пока операция не завершится. 
		* new input/output - возможна работа с несколькими каналами (спс селектор), использует буфер вместо потока, возможно двигаться по буферу вперед и назад.

	5. дженерики
		* все классы параметры должны быть наследованы от object
		* сокращает дублирование кода, избавляет от использования оболочек, повышает читаемость кода
		* обобщенные методы - методы которые принимают и возвращают обобщенные типы данных(public static <T> void a(T[] b))
		* обобщенные классы - классы которые принимают и возвращают обобщенные типы данных(public class a<T>)
		* если непонятно что указывать то пишется ?(wildcard - неограниченный подстановочный тип), может обрабатывать любые колелкции, но нельзя добавлять туда элементы иначе будет ошибка компиляции (кроме нулл)
		* разница между ? и Т - ? неизвестный, Т - указывается в момент использования класса или метода 
		* 

	6. iterator/iterable
		* iterable - можно создавать свой итератор по необходимости (for each)
		* iterator - выбираем если нужно менять в процессе итерации (hasnext)

	7. стирание типов
		* замена параметра типов на стиранную версию (list<String> -> list) для более старых версий
		* старый код без дженериков может быть использован с новым кодом без изменений
		* снижение безопасности при работе, потому что нет типов параметра 

	8. класс File
		* абстракция для работы с файлами и директориями (создание объекта, проверка свойств файлов, работа с путями, чтение директорий )

	9. класс buffer
		* чтение данных, запись данных при работе с потоками, читает файлы, массивы байт
		* лучше, чем io, потому что "улучшение производительности, уменьшение количества обращений к физическому устройству ввода-вывода и сокращение времени выполнения операций ввода-вывода"

	10. stream chains 
		* компактная форма, параллельная обработка, много операций, есть ленивые операции, которые запускаются тоько при вызове терминальной операции, используются функциональные интерфейсы